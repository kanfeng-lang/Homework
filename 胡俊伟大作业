#include "../tasks/detector.hpp"
#include "../tools/img_tools.hpp"
#include "fmt/core.h"
#include <cmath>
// 弹道解算函数
struct BallisticSolution {
    double yaw;      // 水平转角
    double pitch;    // 俯仰角 
    double time;     // 飞行时间
    bool feasible;   // 是否可击中
};

BallisticSolution calculateBallistic(const cv::Mat& tvec, double bullet_speed) {
    BallisticSolution solution;
    
    // 从相机坐标系提取目标位置
    double x = tvec.at<double>(0);  // 水平偏移
    double y = tvec.at<double>(1);  // 垂直偏移（注意：相机坐标系y向下为正）
    double z = tvec.at<double>(2);  // 距离
    
    // 实际物理坐标系（y向上为正）
    double target_x = x;
    double target_y = -y;  // 转换为物理坐标系（y向上为正）
    double target_z = z;
    
    // 计算水平距离
    double horizontal_distance = sqrt(target_x * target_x + target_z * target_z);
    
    // 重力加速度
    double g = 9.8;
    
    // 弹道解算方程
    // 水平方向：d = v₀ * cos(θ) * t
    // 垂直方向：h = v₀ * sin(θ) * t - 0.5 * g * t²
    // 消去t得到：h = d * tan(θ) - (g * d²) / (2 * v₀² * cos²(θ))
    
    double v0 = bullet_speed;
    double d = horizontal_distance;
    double h = target_y;
    
    // 解一元二次方程求tan(θ)
    double A = g * d * d / (2 * v0 * v0);
    double B = -d;
    double C = A + h;
    
    double discriminant = B * B - 4 * A * C;
    
    if (discriminant < 0) {
        // 无实数解，无法击中
        solution.feasible = false;
        return solution;
    }
    
    // 计算两个可能的解（高抛和低抛）
    double tan_theta1 = (-B + sqrt(discriminant)) / (2 * A);
    double tan_theta2 = (-B - sqrt(discriminant)) / (2 * A);
    
    // 选择较小的角度（更直接的弹道）
    double tan_theta = (fabs(tan_theta1) < fabs(tan_theta2)) ? tan_theta1 : tan_theta2;
    
    // 计算角度
    solution.pitch = atan(tan_theta);
    solution.yaw = atan2(target_x, target_z);
    
    // 计算飞行时间
    solution.time = d / (v0 * cos(solution.pitch));
    solution.feasible = true;
    
    return solution;
}

//  相机内参
static const cv::Mat camera_matrix =
    (cv::Mat_<double>(3, 3) <<  1286.307063384126 , 0                  , 645.34450819155256, 
                                0                 , 1288.1400736562441 , 483.6163720308021 , 
                                0                 , 0                  , 1                   );
// 畸变系数
static const cv::Mat distort_coeffs =
    (cv::Mat_<double>(1, 5) << -0.47562935060124745, 0.21831745829617311, 0.0004957613589406044, -0.00034617769548693592, 0);
// clang-format on

static const double LIGHTBAR_LENGTH = 0.056; // 灯条长度    单位：米
static const double ARMOR_WIDTH = 0.135;     // 装甲板宽度  单位：米


// #### Task 01 ############################################
// object_points 是 物体局部坐标系下 n个点 的坐标。
// 对于我们而言，也就是装甲板坐标系下4个点的坐标。
// 请你填写下面的 object_points:

static const std::vector<cv::Point3f> object_points {
    {-ARMOR_WIDTH / 2, -LIGHTBAR_LENGTH / 2, 0},  // 左上角
    {ARMOR_WIDTH / 2, -LIGHTBAR_LENGTH / 2, 0},   // 右上角  
    {ARMOR_WIDTH / 2, LIGHTBAR_LENGTH / 2, 0},    // 右下角
    {-ARMOR_WIDTH / 2, LIGHTBAR_LENGTH / 2, 0}    
};

// 提示： // - 装甲板坐标系是三维的坐标系，但是四个点都在 z 坐标为 0 的平面上，所以已经为你填写了四个 0 。
// - 在上方定义有 灯条长度 和 装甲板宽度，你应当用 "± ARMOR_WIDTH / 2" 这样的写法来填写。
// #########################################################
int main(int argc, char *argv[])
{
    auto_aim::Detector detector;

    cv::VideoCapture cap("video.avi");
    cv::Mat img;

    while (true)
    {
        cap >> img;
        if (img.empty()) // 读取失败 或 视频结尾
            break;

        auto armors = detector.detect(img);

        if (!armors.empty())
        {
            auto armor = armors.front();           // 如果识别到了大于等于一个装甲板，则取出第一个装甲板来处理
            tools::draw_points(img, armor.points); // 绘制装甲板


            // #### Task 02 ############################################
            // img_points 是 像素坐标系下 n个点 的坐标。
            // 对于我们而言，也就是 照片上 装甲板 4个点的坐标。
            // 请你填写下面的 img_points:
            //
            std::vector<cv::Point2f> img_points{
    armor.points[0],  // left top
    armor.points[1],  // right top  
    armor.points[2],  // right bottom
    armor.points[3]   // left bottom
};
            //
            // 提示：
            // - 看看 Armor 结构体有哪些成员。
            // - armor 的成员 left 和 right 是两根灯条(Lightbar)。
            // - 灯条Lightbar也是结构体，灯条的顶部和底部端点就是我们要的点了。
            // #########################################################



            // #### Task 03 ############################################
            cv::Mat rvec, tvec;
            // 所有要传入的值都已经具备了。现在调用 solvePnP 解算装甲板位姿，
            // rvec 和 tvec 用于存储 solvePnP 输出的结果。
            // 你需要在下面填写 输入给 solvePnP 的参数：
            //
            cv::solvePnP(object_points, img_points, camera_matrix, distort_coeffs, rvec, tvec);
            //
            // #########################################################



            // #### Task 04 ############################################
            // 现在，draw_text 只打印 0.0
            // 请你改写下面draw_text的参数，把解得的 tvec 和 rvec 打印出来
            //
           tools::draw_text(img, fmt::format("tvec:  x{: .2f} y{: .2f} z{: .2f}", 
    tvec.at<double>(0), tvec.at<double>(1), tvec.at<double>(2)), 
    cv::Point2f(10, 60), 1.7, cv::Scalar(0, 255, 255), 3);

            tools::draw_text(img, fmt::format("rvec:  x{: .2f} y{: .2f} z{: .2f}", 
    rvec.at<double>(0), rvec.at<double>(1), rvec.at<double>(2)), 
    cv::Point2f(10, 120), 1.7, cv::Scalar(0, 255, 255), 3);
            // 提示：
            // - 使用 tvec.at<double>(0)，可以得到一个double变量，它是tvec中首个元素的值。
            // #########################################################



            // #### Task 05 ############################################
            // 使用 cv::Rodrigues ，把 rvec 旋转向量转换为 rmat 旋转矩阵。
            // 再使用反三角函数，把旋转矩阵 rmat 中的元素转化为欧拉角，并在画面上显示。
            //
            tools::draw_text(img, fmt::format("euler angles:  yaw{: .2f} pitch{: .2f} roll{: .2f}", 0.0, 0.0, 0.0), cv::Point2f(10, 180), 1.7, cv::Scalar(0, 255, 255), 3);
            cv::Mat rmat;
cv::Rodrigues(rvec, rmat);

// 计算欧拉角
double yaw = atan2(rmat.at<double>(1,0), rmat.at<double>(0,0));
double pitch = atan2(-rmat.at<double>(2,0), 
    sqrt(rmat.at<double>(2,1)*rmat.at<double>(2,1) + rmat.at<double>(2,2)*rmat.at<double>(2,2)));
double roll = atan2(rmat.at<double>(2,1), rmat.at<double>(2,2));

tools::draw_text(img, fmt::format("euler angles:  yaw{: .2f} pitch{: .2f} roll{: .2f}", 
    yaw, pitch, roll), cv::Point2f(10, 180), 1.7, cv::Scalar(0, 255, 255), 3);
            // 提示：
            // - cv::Mat 的下标从0开始，而不是1。
            // - 从cv::Mat 中取元素的方法和上面的 tvec 类似。如： rmat.at<double>(0, 2)
            // #########################################################
            // 弹道解算（新增部分）
    double bullet_speed = 15.0; // 子弹速度 m/s，根据实际情况调整
    BallisticSolution ballistic = calculateBallistic(tvec, bullet_speed);
    
    if (ballistic.feasible) {
        tools::draw_text(img, 
            fmt::format("弹道: yaw{: .2f} pitch{: .2f}", ballistic.yaw, ballistic.pitch), 
            cv::Point(10, 120), 1.0, cv::Scalar(0, 255, 0), 2);
        tools::draw_text(img, 
            fmt::format("飞行时间: {:.2f}s", ballistic.time), 
            cv::Point(10, 150), 1.0, cv::Scalar(0, 255, 0), 2);
    } else {
        tools::draw_text(img, "目标不可达", 
            cv::Point(10, 120), 1.0, cv::Scalar(0, 0, 255), 2);}

        }

        cv::imshow("press q to quit", img);

        if (cv::waitKey(20) == 'q')
            break;
    }

    cv::destroyAllWindows();
    return 0;
}
